% Prolog test file
%
%%%%%%%%%  reminder to staff: do NOT edit this file by hand.
%                             it was generated automatically.
%

% for a specific part, to test everything interactively:
%    -- enter gprolog:
%          gprolog
%    -- consult the files for these tests and for your code:
%          consult('../test.pl').
%          consult('sched.pl').
%    -- use one of the ty predicates to test everything
%       for example, in part 1, give the command:
%          ty1.
%    -- exit gprolog:
%          ^D
%    -- compare your output vs. correct output:
%          diff Output.correct Output.your
%       or
%          tkdiff Output.correct Output.your
%
%       files must be identical.
%
%
% you might find some of the other functions below helpful in your testing
% e.g., to test all of part2 (and all of part1)
%       w/o writing to Output.your, use
%          test-part2.
% e.g., to test only all of part2 but none of part1
%        w/o writing to Output.your, use
%          test-only-part2.

% the tests sort the outputs of the scheduling predicates.
% reason: 
%    the order in which you generate answers
%    and whether you do or do not generate duplicates
%    might differ from that for the code that generated the correct output.
% sorting eliminates those differences.
%
% if you want to see the UNSORTED output of your scheduling predicates,
% you can include the UNSORTED tests.
% if you do, though, your output will of course differ from the correct output
% (but only by including UNSORTED sections).
% to include those tests,
%    if you are running the tests interactively,
%       after you have consulted files, just type:
%          testUnsortedShow.
%    if you are using batch testing,
%        put this line at the end of your sched.pl:
%           :- initialization(testUnsortedShow).

% the format of each test differs slightly from
% the equivalent interactive test, although it is straightforward to
% extract the interactive test if you want to test something
% individually, as you might during debugging.  roughly:
%  -- remove the ``all'' predicate and any string arguments (e.g., "X" or "Z").
%  -- add parentheses after predicate name.
%  -- put . at end instead of , (if necessary).
% E.g.,
%	all3iio( delete, [1], 1, Z, "Z")
% represents
%	delete( [1], 1, Z ).

testOneSaveOutput(TestPartFunction) :-
       saveOutputBegin,
       testOne(TestPartFunction),
       saveOutputEnd.
testOne(TestPartFunction) :-
       call(TestPartFunction).
       
saveOutputBegin :- tell('Output.your').
saveOutputEnd :- told.

% control UNSORTED testing; by default, it is turned off.
:- dynamic(testUnsorted/1).
testUnsorted(false).    
testUnsortedShow :- 
    assertz(testUnsorted(true)).
% note of interest only to writer (not to user) of test.pl: 
%    considered other ways to handle unsorted, but decided this was easiest.
%       e.g., could:
%         (1) generate it and filter it out via shell script.
%         (2) use telling predicate to test whether outputting to file
%             (telling(X) will give X=user
%              if so, change via tell('Output.yoursUnsorted')
%             and later restore via tell (or append).

% part tests (each tests all previous parts and all in this part)
% output saved to a file
ty1 :-
	saveOutputBegin,
	test_part1,
	saveOutputEnd.
ty2 :-
	saveOutputBegin,
	test_part2,
	saveOutputEnd.
ty3 :-
	saveOutputBegin,
	test_part3,
	saveOutputEnd.
ty4 :-
	saveOutputBegin,
	test_part4,
	saveOutputEnd.
ty5 :-
	saveOutputBegin,
	test_part5,
	saveOutputEnd.
ty6a :-
	saveOutputBegin,
	test_part6a,
	saveOutputEnd.
ty6b :-
	saveOutputBegin,
	test_part6b,
	saveOutputEnd.
ty7a :-
	saveOutputBegin,
	test_part7a,
	saveOutputEnd.
ty7b :-
	saveOutputBegin,
	test_part7b,
	saveOutputEnd.
ty7c :-
	saveOutputBegin,
	test_part7c,
	saveOutputEnd.
ty7d :-
	saveOutputBegin,
	test_part7d,
	saveOutputEnd.
ty7e :-
	saveOutputBegin,
	test_part7e,
	saveOutputEnd.
% part tests (each tests all previous parts and all in this part)
test_part1 :- test_only_part1.
test_part2 :-
	test_part1,
	test_only_part2.
test_part3 :-
	test_part2,
	test_only_part3.
test_part4 :-
	test_part3,
	test_only_part4.
test_part5 :-
	test_part4,
	test_only_part5.
test_part6a :-
	test_part5,
	test_only_part6a.
test_part6b :-
	test_part6a,
	test_only_part6b.
test_part7a :-
	test_part6b,
	test_only_part7a.
test_part7b :-
	test_part7a,
	test_only_part7b.
test_part7c :-
	test_part7b,
	test_only_part7c.
test_part7d :-
	test_part7c,
	test_only_part7d.
test_part7e :-
	test_part7d,
	test_only_part7e.
% some shorthands, so that you can just type, e.g., tp1
tp1 :- test_part1.
tp2 :- test_part2.
tp3 :- test_part3.
tp4 :- test_part4.
tp5 :- test_part5.
tp6a :- test_part6a.
tp6b :- test_part6b.
tp7a :- test_part7a.
tp7b :- test_part7b.
tp7c :- test_part7c.
tp7d :- test_part7d.
tp7e :- test_part7e.
top1 :- test_only_part1.
top2 :- test_only_part2.
top3 :- test_only_part3.
top4 :- test_only_part4.
top5 :- test_only_part5.
top6a :- test_only_part6a.
top6b :- test_only_part6b.
top7a :- test_only_part7a.
top7b :- test_only_part7b.
top7c :- test_only_part7c.
top7d :- test_only_part7d.
top7e :- test_only_part7e.
% part specific tests
test_only_part1 :- test_pizza.
test_only_part2 :-
	test_toe,
	test_extract.
test_only_part3 :-
	test_pizza2,
	test_extractfindall.
test_only_part4 :- test_iscontiguous.
test_only_part5 :- test_mapcar.
test_only_part6a :-
	test_selectNv0,
	test_sortedSelectNv0.
test_only_part6b :-
	test_selectN,
	test_sortedSelectN.
test_only_part7a :- test_sws0.
test_only_part7b :- test_sws2.
test_only_part7c :- test_sws4.
test_only_part7d :- test_sws6.
test_only_part7e :- test_sws8.
% some abbreviations, so that you can just type, e.g., tz
tz :- test_pizza.
te :- test_toe.
tx :- test_extract.
tz2 :- test_pizza2.
tf :- test_extractfindall.
ti :- test_iscontiguous.
tm :- test_mapcar.
ts0 :- test_selectNv0.
tss0 :- test_sortedSelectNv0.
ts :- test_selectN.
tss :- test_sortedSelectN.
tw0 :- test_sws0.
tw2 :- test_sws2.
tw4 :- test_sws4.
tw6 :- test_sws6.
tw8 :- test_sws8.
/* define some facts for the first part.
 * note: these *approximate* some likely yummy pizzas.
 */
pizza(shroom,         red,     [mushrooms]).
pizza(popeye,         white,   [spinach, olives]).
pizza(veggie,         red,     [mushrooms, olives, artichokehearts]).
pizza(aubergine,      red,     [eggplant]).

pizza(meattie,        red,     [pepperoni, sausage, salami]).
pizza(supreme,        red,     [pepperoni, sausage, olives, mushrooms]).
pizza(sals,           white,   [salami, olives, mushrooms]).
pizza(pepperronionly, red,     [pepperoni]).

pizza(basic,          red,     []).
pizza(combo,          pink,    [sausage, eggplant]).


/************** order ***********/
test_iscontiguous :-
  test_iscontiguouspremade,
  test_iscontiguousdiy.

test_iscontiguouspremade :-
	nl, printstring("TESTING ISCONTIGUOUSPREMADE"), nl, nl,
	test_an_iscontiguous(iscontiguouspremade).

test_iscontiguousdiy :-
	test_an_iscontiguous(iscontiguousdiy).


test_an_iscontiguous(Which) :-
	nl, printstring("TESTING an ISCONTIGUOUSDIY"), write(Which), nl, nl,
	all1i(  Which, [] ),
	all1i(  Which, [1] ),
	all1i(  Which, [1, 2] ),
	all1i(  Which, [1, 2, 3] ),
	all1i(  Which, [5, 6, 7] ),
	all1i(  Which, [1, 3] ),
	all1i(  Which, [1, 3, 5] ),
	all1i(  Which, [1, 2, 3, 5] ),
	all1i(  Which, [1, 2, 8, 9] ),
	all1i(  Which, [1, 2, 8, 19] ),
	all1i(  Which, [5, 6, 7, 19] ).


/************** order ***********/

%%%%%%%%%%% reorder
test_mapcar :-
	nl, printstring("TESTING MAPCAR"), nl, nl,
	all3iio(  mapcar, last, [], Z, "Z" ),
	all3iio(  mapcar, last, [[1],[1,2],[1,2,3]], Z, "Z" ),
        % if Predicate fails on any element, then whole mapcar fails.
        % e.g., on next test, last fails on [].
	all3iio(  mapcar, last, [[],[a],[a,b],[a,b,c]], Z, "Z" ),
	all3iio(  mapcar, length, [[],[a],[a,b],[a,b,c]], Z, "Z" ).

test_selectNv0 :-
	nl, printstring("TESTING selectNv0"), nl, nl,
	test_a_selectN(selectNv0).

% note how sort *N-tuple after* selectNv0
sortedSelectNv0(N,SortedTuple,L,R) :-
%	effect a
%	    selectNv0(N,UnsortedTuple,L,R),
%	using indirection so that can compile this code
%	w/o having stub for selectNv0.
	indirect_selectN_Predicate(selectNv0,N,UnsortedTuple,L,R),
	sort(UnsortedTuple,SortedTuple).
indirect_selectN_Predicate(Predicate,A1,A2,A3,A4) :-
	T =..[Predicate,A1,A2,A3,A4], call(T).

test_sortedSelectNv0 :-
	nl, printstring("TESTING sortedSelectNv0"), nl, nl,
	test_a_selectN(sortedSelectNv0).

test_selectN :-
	nl, printstring("TESTING selectN"), nl, nl,
	test_a_selectN(selectN).

% note how sort *list before* selectN
sortedSelectN(N,SortedTuple,L,R) :-
	sort(L, SortedL),
%	effect a
%	    selectN(N,SortedTuple,SortedL,R).
%	using indirection so that can compile this code
%	w/o having stub for selectN.
	indirect_selectN_Predicate(selectN,N,SortedTuple,SortedL,R).

test_sortedSelectN :-
	nl, printstring("TESTING sortedSelectN"), nl, nl,
	test_a_selectN(sortedSelectN).

/******* for now.......
test_sortPickN0 :-
	nl, printstring("TESTING sortPickN0"), nl, nl,
	test_a_pickN(sortPickN0).
********/
test_a_selectN(Which) :-
	nl, printstring("TESTING a selectN "), write(Which), nl, nl,
	all4ioio(  Which, 5, Z, [], R, "Z", "R" ),
	all4ioio(  Which, 1, Z, [a], R, "Z", "R" ),
	all4ioio(  Which, 2, Z, [a], R, "Z", "R" ),
	all4ioio(  Which, 1, Z, [a, b], R, "Z", "R" ),
	all4ioio(  Which, 2, Z, [a, b], R, "Z", "R" ),
	all4ioio(  Which, 2, Z, [b, a], R, "Z", "R" ),
	all4ioio(  Which, 3333, Z, [a, b], R, "Z", "R" ),
	all4ioio(  Which, 1, Z, [a, b, c], R, "Z", "R" ),
	all4ioio(  Which, 2, Z, [a, b, c], R, "Z", "R" ),
	all4ioio(  Which, 2, Z, [b, a, c], R, "Z", "R" ),
	all4ioio(  Which, 2, Z, [c, b, a], R, "Z", "R" ),
	all4ioio(  Which, 3, Z, [a, b, c], R, "Z", "R" ),
	all4ioio(  Which, 4, Z, [a, b, c], R, "Z", "R" ),
	all4ioio(  Which, 3, Z, [a, b, c, d], R, "Z", "R" ).

test_sws0000 :-
	nl, printstring("TESTING SWS0000"), nl, nl,
	all4iioo(  sws0000, [], [], K, M, "K", "M" ),
	all4iioo(  sws0000, [], [1], K, M, "K", "M" ),
	all4iioo(  sws0000, [joe], [1], K, M, "K", "M" ),
	all4iioo(  sws0000, [joe], [], K, M, "K", "M" ),
	all4iioo(  sws0000, [eva, joe], [1], K, M, "K", "M" ),
	all4iioo(  sws0000, [eva], [1,2], K, M, "K", "M" ),
	all4iioo(  sws0000, [eva, joe], [1,2], K, M, "K", "M" ),
	all4iioo(  sws0000, [eva, joe, sue], [1,2], K, M, "K", "M" ),
	all4iioo(  sws0000, [eva, joe], [1,2, 3], K, M, "K", "M" ).

%%%% "standard" data format
test_sws0 :-
	nl, printstring("TESTING SWS0"), nl, nl,
	test_an_sws(sws0).

test_sws2 :-
	nl, printstring("TESTING SWS2"), nl, nl,
	test_an_sws(sws2).

test_sws4 :-
	nl, printstring("TESTING SWS4"), nl, nl,
	test_an_sws(sws4).

test_sws6 :-
	nl, printstring("TESTING SWS6"), nl, nl,
	test_an_sws(sws6).

test_sws8 :-
	nl, printstring("TESTING SWS8"), nl, nl,
	test_an_sws(sws8).

test_an_sws(Which) :-
	nl, printstring("TESTING an SWS "), write(Which), nl, nl,
	all4iioo(  Which, [], [], K, M, "K", "M" ),
	all4iioo(  Which, [], [[1,1]], K, M, "K", "M" ),
	all4iioo(  Which, [[joe,2]], [[1,1]], K, M, "K", "M" ),
	all4iioo(  Which, [[joe,2]], [], K, M, "K", "M" ),
	all4iioo(  Which, [[eva,3], [joe,2]], [[1,1]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva,3]], [[1,1],[2,3]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva,3], [joe,2]], [[1,1],[2,3]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva,3], [joe,2], [sue,1]], [[1,1],[2,3]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva,3], [joe,2]], [[1,1], [2,3], [3,2]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva, 3], [joe,2]], [[1,1],[2,3]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva, 3], [joe,2], [kim,2], [sue,1]], [[1,1],[2,3]], K, M, "K", "M" ),
	all4iioo(  Which, [[joe,2]], [[1,1],[2,1]], K, M, "K", "M" ),
	all4iioo(  Which, [[joe,2]], [[1,2]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva,1], [joe,2]], [[1,1],[2,1]], K, M, "K", "M" ),
	all4iioo(  Which, [[eva,1], [joe,2]], [[1,1],[2,1],[3,1]], K, M, "K", "M" ),
%%%%%%%%%%%%% non-contiguous time slots :
	all4iioo(  Which, [[eva,1], [joe,2]], [[1,1],[4,1],[5,1]], K, M, "K", "M" ).
%%%%%%%%%%% need more test, especially non-contiguous ones.

/***************** xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxx



xxxxxxxxxxxxxxxxxx************/

test_pizza :-
	nl, printstring("TESTING Z_s"), nl, nl,
	all1o(  z_names, N, "Name"),
	all1o(  z_red, N, "Name"),
	all1o(  z_notred, N, "Name"),
	all1o(  z_veggie_toppings, L, "List_of_toppings_of_veggie"),
	all1o(  z_veggie_toppings_sorted, L, "Sorted_list_of_toppings_of_veggie"),
	all1o(  z_popeye_toppings, L, "List_of_toppings_of_popeye"),
	all1o(  z_popeye_toppings_sorted, L, "Sorted_list_of_toppings_of_popeye"),
	all2io( z_toppings_sorted, veggie, L, "Sorted_List_of_toppings"),
	all2io( z_toppings_sorted, popeye, L, "Sorted_List_of_toppings"),
	all2io( z_toppings_sorted, basic, L, "Sorted_List_of_toppings"),
	all2io( z_toppings_sorted, combo, L, "Sorted_List_of_toppings"),
	all2io( z_toppings_sorted, meattie, L, "Sorted_List_of_toppings"),
	all1i( z_are_toppings_sorted, meattie),
	all1i( z_are_toppings_not_sorted, meattie),
	all1i( z_are_toppings_sorted, supreme),
	all1i( z_are_toppings_not_sorted, supreme),
	all1i( z_are_toppings_sorted, basic),
	all1i( z_are_toppings_not_sorted, basic),
	all1i( z_are_toppings_sorted, shroom),
	all1i( z_are_toppings_not_sorted, shroom),

	all1o(  z_single_topping, N, "Name"),
	all1o(  z_multi_toppings, N, "Name"),
	all1o(  z_3ormore_toppings, N, "Name"),
	all1o(  z_12_toppings_1or, N, "Name"),
	all1o(  z_12_toppings_2wo, N, "Name"),
	all1o(  z_red_single_topping, N, "Name"),
	all1o(  z_white_single_topping, N, "Name").

test_pizza2 :-
	nl, printstring("TESTING MORE Z_s"), nl, nl,
	all1o(  z_mushrooms, N, "Name"),
	all1o(  z_holdthemushrooms, N, "Name"),
	all2io( z_toppings, veggie, T, "Topping"),
	all2io( z_toppings, basic, T, "Topping"),
	all2io( z_toppings, combo, T, "Topping"),
	all1o(  z_nonolives, _ToppingsList, "List of non-olives toppings"),
	all1o(  z_multi_toppings_list, _NamesList, "List of Names"),
	all0(   z_multi_toppings_list_have_red_sauce),
	all0(   z_multi_toppings_list_have_toppings_not_sorted).

test_toe :-
	nl, printstring("TESTING TOE"), nl, nl,
	all3iio( toe, 5, [], Z, "Z"),
	all3iio( toe, 5, [[a]], Z, "Z"),
	all3iio( toe, 5, [[a], [b]], Z, "Z"),
	all3iio( toe, 5, [[a], [b], [c]], Z, "Z"),
	all3iio( toe, 5, [[a, 1], [b, 1], [c, 1]], Z, "Z").

test_extract :-
	nl, printstring("TESTING EXTRACT"), nl, nl,
	test_an_extract(extract).

test_extractfindall :-
	nl, printstring("TESTING EXTRACTFINDALL"), nl, nl,
	test_an_extract(extractfindall).

test_an_extract(Which) :-
	nl, printstring("TESTING an EXTRACT "), write(Which), nl, nl,
	all2io( Which, [], Z, "Z"),
	all2io( Which, [[eva,3]], Z, "Z"),
	all2io( Which, [[eva,3],[joe,2]], Z, "Z"),
	all2io( Which, [[eva,3],[joe,2],[sue,5]], Z, "Z").

test_lists :-
	test_toe,
	test_extract.

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A3 and A4,
 * whose names are in the string SA3 and SA4.
 */
all4iioo(Predicate,A1,A2,A3,A4,SA3,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), printstring(SA3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4], call(T),
	printstring(SA3), printstring(" = "),
	write(A3), nl,
	printstring(SA4), printstring(" = "),
	write(A4), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A2 and A4,
 * whose names are in the string SA2 and SA4.
 */
all4ioio(Predicate,A1,A2,A3,A4,SA2,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), printstring(SA2),
	printstring(","), write(A3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4], call(T),
	printstring(SA2), printstring(" = "),
	write(A2), nl,
	printstring(SA4), printstring(" = "),
	write(A4), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A4, whose name is in the string SA4.
 * like all4iiio, but sorts.
 */
sort4iiio(Predicate,A1,A2,A3,A4,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), write(A3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4],
	findall(A4,call(T),L),
	sort(L,SL),
	printstring("SL"), printstring(" = "),
	write(SL), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3, A4
 * assume output goes only to A4, whose name is in the string SA4.
 */
all4iiio(Predicate,A1,A2,A3,A4,SA4) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), write(A3),
	printstring(","), printstring(SA4),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3,A4], call(T),
	printstring(SA4), printstring(" = "),
	write(A4), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3
 * assume output goes only to A3, whose name is in the string SA3.
 */
all3iio(Predicate,A1,A2,A3,SA3) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(","), printstring(SA3),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3], call(T),
	printstring(SA3), printstring(" = "),
	write(A3), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3
 * assume output goes only to A1, whose name is in the string SA1.
 */
all3oii(Predicate,A1,A2,A3,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(","), write(A2),
	printstring(","), write(A3),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3], call(T),
	printstring(SA1), printstring(" = "),
	write(A1), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2, A3
 * assume output goes only to A2, whose name is in the string SA2.
 */
all3ioi(Predicate,A1,A2,A3,SA2) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), printstring(SA2),
	printstring(","), write(A3),
	printstring(")"), nl,
	T =..[Predicate,A1,A2,A3], call(T),
	printstring(SA2), printstring(" = "),
	write(A2), nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate on A1, A2
 * assume output goes to A2, whose name is in the string SA2.
 */
all2io(Predicate,A1,A2,SA2) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), printstring(SA2),
	printstring(")"), nl,
	T =..[Predicate,A1,A2], call(T),
	printstring(SA2), printstring(" = "),
	write(A2), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1, A2
 * assume output goes to A1, whose name is in the string SA1.
 */
all2oi(Predicate,A1,A2,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(","), write(A2),
	printstring(")"), nl,
	T =..[Predicate,A1,A2], call(T),
	printstring(SA1), printstring(" = "),
	write(A1), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1 and A2
 * assume yes or no as output.
 */
all2ii(Predicate,A1,A2) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(","), write(A2),
	printstring(")"), nl,
	T =..[Predicate,A1,A2],
	((call(T),printstring("yes"));( \+ T ,printstring("no"))),
	nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1
 * assume output goes only to A1, whose name is in the string SA1.
 */
all1o(Predicate,A1,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(")"), nl,
	T =..[Predicate,A1], call(T),
	printstring(SA1), printstring(" = "),
	write(A1), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1
 * assume output goes only to A1, whose name is in the string SA1.
 */
all1ostring(Predicate,A1,SA1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), printstring(SA1),
	printstring(")"), nl,
	T =..[Predicate,A1], call(T),
	printstring(SA1), printstring(" = "),
	printstring(A1), nl, nl,
	fail; true.
	
/* semi-general tester.
 * run Predicate on A1
 * input is A1;
 * as with other testing predicates,
 * output is yes if success or nothing if failure.
 * (written to make generates all possible yes answers too.)
 */
all1i(Predicate,A1) :-
	printstring("testing: "), write(Predicate),
	printstring("("), write(A1),
	printstring(")"), nl,
	T =..[Predicate,A1],
        call(T), printstring("yes"),
	nl, nl,
	fail; true.

/* semi-general tester.
 * run Predicate
 * no input, no output;
 * as with other testing predicates,
 * output is yes if success or nothing if failure.
 * (written to make generates all possible yes answers too.)
 */
all0(Predicate) :-
	printstring("testing: "), write(Predicate), nl,
	T =..[Predicate],
        call(T), printstring("yes"),
	nl, nl,
	fail; true.

/* a way to output strings. */
printstring([]).
printstring([H|T]) :- put(H), printstring(T).

% re-consult your code:
ys :-   consult('sched.pl').
% re-consult everything:
yy :-
	consult('sched.pl'),
	consult('../test.pl').

% useful to save typing (but mainly for me, not students since they
% will rarely need to reload test.pl within a session) ...
yt :- consult('../test.pl').
